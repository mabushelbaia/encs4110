---
outline: deep
lastUpdated: true
next: false
---

# Liquid Crystal Display (LCD) <Badge type="tip" text="Experiment 9" />

![alt text](/image-3.png)


## Introduction

The 16x2 LCD module (HD44780 controller) is commonly used in embedded systems to display text. It shows 16 characters per line on 2 lines. This guide explains how to interface it with the TM4C123 microcontroller using the efficient **4-bit mode**.


### LCD Basics

* **Registers:**

  * *Command Register:* Sends instructions (e.g., clear display).
  * *Data Register:* Sends characters to display.
* **Control Pins:**

  * *RS:* Selects command or data register.
  * *RW:* Selects read or write mode.
  * *E:* Enables data latch.
* **Data Pins:**

  * *D0-D7:* Used to send data; in 4-bit mode only D4-D7 are used.

> [!TIP] Important
> Data is sent in two parts: first the upper 4 bits, then the lower 4 bits.Each 8-bit. value requires two writes, toggling the E pin after each to latch the data.


### Initialization Steps (4-bit Mode)

1. Set RS, RW, E to low and wait 40 ms after power-on.
2. Send command `0x30` (upper nibble only) three times with delays (>4.1 ms, >100 μs, >100 μs).
3. Send `0x20` (upper nibble only) to switch to 4-bit mode.
4. Send full commands:

   * `0x28`: 4-bit mode, 2 lines, 5x7 dots
   * `0x0C`: Display on, cursor off, blink off
   * `0x06`: Increment cursor, no display shift
   * `0x01`: Clear display
   * `0x02`: Return home

> [!NOTE] Note
> Steps 2-3 send only the upper nibble since LCD isn’t in 4-bit mode yet. After step 3, send full 8-bit commands in two nibbles.


### LCD Commands
| Command             | Hex Range       | Description & Details                                                                                   |
|---------------------|-----------------|-------------------------------------------------------------------------------------------------------|
| **Clear Display**    | `0x01`          | Clears screen, sets cursor to home (address 0).                                                       |
| **Return Home**      | `0x02`          | Cursor returns to home (address 0).                                                                   |
| **Entry Mode Set**   | `0x04`–`0x07`   | Controls cursor move direction & display shift:                                                       |
|                     |                 | - `0x04`: cursor moves left, no shift                                                                 |
|                     |                 | - `0x06`: cursor moves right, no shift (default)                                                      |
|                     |                 | - Others enable display shift while moving cursor                                                     |
| **Display Control**  | `0x08`–`0x0F`   | Turns display, cursor, and blink on/off:                                                              |
|                     |                 | - `0x08`: display off                                                                                  |
|                     |                 | - `0x0C`: display on, cursor off                                                                       |
|                     |                 | - `0x0E`: display and cursor on                                                                        |
|                     |                 | - `0x0F`: display, cursor, and blink on                                                                |
| **Cursor/Display Shift** | `0x10`–`0x1F`| Shifts cursor or display left or right.                                                               |
|                     | `0x18`          | Shift display left                                                                                      |
|                     | `0x1C`          | Shift display right                                                                                     |
| **Set DDRAM Address**| `0x80` + addr   | Moves cursor to DDRAM address (e.g., `0x80` start of 1st line, `0xC0` start of 2nd line).             |
| **Function Set**     | `0x20`–`0x3F`   | Sets interface parameters (bit flags):                                                                |
|                     |                 | - Bit 4: Data length (0=4-bit, 1=8-bit)                                                               |
|                     |                 | - Bit 3: Number of lines (0=1 line, 1=2 lines)                                                        |
|                     |                 | - Bit 2: Font type (0=5x8 dots, 1=5x10 dots)                                                          |
|                     |                 | Example: `0x28` = 4-bit, 2 lines, 5x8 font                                                             |


## Example Code

```c [main.c]
#include "TM4C123.h"

// Define control pins (PB0: RS, PB2: EN)
#define RS 0x01        // PB0
#define EN 0x04        // PB2
#define DATA_MASK 0xF0 // PB4-PB7 for D4-D7

// Function prototypes
void LCD_Init(void);
void LCD_Command(unsigned char command);
void LCD_Data(unsigned char data);
void LCD_Clear(void);
void LCD_SetCursor(unsigned char row, unsigned char col);
void LCD_Print(char *str);
void delay_ms(int ms);
void delay_us(int us);
void LCD_EnablePulse(void);
void LCD_SendNibble(unsigned char nibble);
void SysTick_Init(void);

int main(void)
{

    LCD_Init();
    LCD_Clear();        // Ensure display is clear
    LCD_SetCursor(0,0); // Set cursor to beginning
    LCD_Print("ENCS4110 Lab");
    
    while(1)
    {
        // Main loop
    }
}

void SysTick_Init(void)
{
    SysTick->CTRL = 0;                   // Disable SysTick during setup
    SysTick->LOAD = 16000000/1000 - 1;   // Load value for 1ms delay at 16MHz
    SysTick->VAL = 0;                    // Clear current value
    SysTick->CTRL = 0x5;                 // Enable SysTick, use system clock
}

void delay_us(int us)
{
    SysTick->LOAD = (16 * us) - 1;     // 16 cycles = 1us at 16MHz
    SysTick->VAL = 0;                  // Clear current value
    SysTick->CTRL |= 0x1;              // Enable SysTick
    while((SysTick->CTRL & 0x10000) == 0); // Wait for COUNT flag
}

void delay_ms(int ms)
{
    SysTick->LOAD = (16000 * ms) - 1;  // 16000 cycles = 1ms at 16MHz
    SysTick->VAL = 0;                  // Clear current value
    SysTick->CTRL |= 0x1;              // Enable SysTick
    while((SysTick->CTRL & 0x10000) == 0); // Wait for COUNT flag
}

void LCD_EnablePulse(void)
{
    delay_us(1);          // Pre-pulse delay
    GPIOB->DATA |= EN;    // EN = 1
    delay_us(1);          // Wait > 450ns
    GPIOB->DATA &= ~EN;   // EN = 0
    delay_us(1);          // Post-pulse delay
}

// Helper function to send a single nibble (4 bits) to the LCD
void LCD_SendNibble(unsigned char nibble)
{
    // Send only the upper 4 bits (connected to PB4-PB7)
    GPIOB->DATA = (GPIOB->DATA & ~DATA_MASK) | (nibble & DATA_MASK);
    LCD_EnablePulse();
}

void LCD_Init(void)
{
    // Enable and wait for clock to PORTB
    SYSCTL->RCGCGPIO |= (1 << 1);
    while((SYSCTL->PRGPIO & (1 << 1)) == 0);
    
    // Configure port B pins
    GPIOB->DIR |= (RS | EN | DATA_MASK);  // Set as outputs
    GPIOB->DEN |= (RS | EN | DATA_MASK);  // Enable digital
    
    // Initialize SysTick for delays
    SysTick_Init();
    
    // Initial state
    GPIOB->DATA &= ~(RS | EN | DATA_MASK);  // All pins low
    delay_ms(50);   // Wait after power up (at least 40ms)
    
    // The crucial three-time 0x30 initiation sequence
    // During initialization, we're only sending the upper nibble (0x3)
    // because the LCD doesn't know it's in 4-bit mode yet

    for (int i = 0; i < 3; i++) {
        LCD_Command(0x30);  // Send 0x30 (upper nibble only) 3 times
    }

    // Switch to 4-bit mode (only sending upper nibble 0x2)
    LCD_Command(0x20);
    
    // Now in 4-bit mode - all subsequent commands will send both nibbles
    LCD_Command(0x28);  // Function set: 4-bit, 2 lines, 5x7 dots
    LCD_Command(0x0C);  // Display ON, cursor OFF, blink OFF
    LCD_Command(0x06);  // Entry mode set: Increment cursor
    LCD_Command(0x01);  // Clear display
    LCD_Command(0x02);  // Return home
}

void LCD_Command(unsigned char command)
{
    GPIOB->DATA &= ~RS;  // RS = 0 for command
    delay_us(1);
    
    // Are we in initialization mode (before 4-bit mode is set)?
    if (command == 0x30 || command == 0x20) {
        // For initialization, we only send the upper nibble
        LCD_SendNibble(command);
    } else {
        // Normal 4-bit operation - send both nibbles
        // Send upper nibble
        LCD_SendNibble(command);
        
        // Send lower nibble
        LCD_SendNibble(command << 4);
    }
    
    delay_ms(2);  // Wait for command to complete
}

void LCD_Data(unsigned char data)
{
    GPIOB->DATA |= RS;  // RS = 1 for data
    delay_us(1);

    // Send upper nibble
    LCD_SendNibble(data);
    
    // Send lower nibble
    LCD_SendNibble(data << 4);
    delay_ms(1);  // Wait for data to be processed
}

void LCD_Clear(void)
{
    LCD_Command(0x01);  // Clear display command
    delay_ms(2);        // Clear command needs 1.52ms
}

void LCD_SetCursor(unsigned char row, unsigned char col)
{
    unsigned char address;
    address = (row == 0) ? 0x80 + col : 0xC0 + col;  // Row 0 or 1
    LCD_Command(address);
    delay_ms(1);
}

void LCD_Print(char *str)
{
    while (*str)
    {
        LCD_Data(*str++); // Print the current character
    }
}
```


## Lab Work

1. **Modify the code**

   Update the existing program to display your `name` on the first line and your `ID` on the second line of the LCD.

2. **Name scrolling with button control**

   Write a program that:

   * Displays your `name` on the LCD.
   * Allows the name to scroll `left` or `right`.
   * Uses the two on-board push buttons (with interrupts) to control the scrolling direction.

3. **Bidirectional shifting after button press**

   Write a program that:
   * Displays your `name` on the first row and your `ID` on the second row.
   * The name (first row) continuously shifts `right`.
   * The ID (second row) continuously shifts `left`.
   * The shifting starts only after a button press by the user.

