---
outline: deep
lastUpdated: true
---

# Flow Control and Addressing Modes

In this experiment, you will learn how to implement **looping**, **branching**, and **decision-making** in ARM Assembly. Additionally, you will explore **various addressing modes** that ARM offers for flexible and efficient memory access.



## Branching

Branching changes the program's execution flow by jumping to another location in memory.

- **Unconditional branch**: `B label`
- **Conditional branch**: Executes only if a specific condition flag is set.
- **Branch with Link (BL)**: Calls a subroutine.
- **Branch and Exchange (BX)**: Returns from subroutine.


## Conditional Execution

ARM supports conditional execution for most instructions by adding a condition suffix.

### Condition Codes

| Suffix | Meaning               | Flags checked |
|--------|-----------------------|---------------|
| EQ     | Equal                 | Z = 1         |
| NE     | Not Equal             | Z = 0         |
| CS/HS  | Carry Set / Unsigned ≥| C = 1         |
| CC/LO  | Carry Clear / Unsigned < | C = 0     |
| MI     | Minus / Negative      | N = 1         |
| PL     | Plus / Positive/Zero  | N = 0         |
| VS     | Overflow Set          | V = 1         |
| VC     | Overflow Clear        | V = 0         |
| HI     | Unsigned >            | C = 1 & Z = 0 |
| LS     | Unsigned ≤            | C = 0 or Z = 1|
| GE     | Signed ≥              | N = V         |
| LT     | Signed <              | N ≠ V         |
| GT     | Signed >              | Z = 0 & N = V |
| LE     | Signed ≤              | Z = 1 or N ≠ V |
| AL     | Always (default)      | —             |

## Load/Store Instructions

Load and Store Instructions have the following format:
```asm
[LABEL] LDR{cond}{mod} Rt, [Rn{, #offset}]
[LABEL] STR{cond}{mod} Rt, [Rn{, #offset}]
```
Where:
- `<mod>` can be one of the following:
    - `B` - Byte (8 bits)
    - `H` - Halfword (16 bits)
    - `SB` - Signed Byte (8 bits)
    - `SH` - Signed Halfword (16 bits)
    - `D` - Doubleword (64 bits) 
- `offset` can be a register, immediate value, or a barrel shifted value.
- `cond` is an optional condition code.


## Addressing Modes

Common ways to access memory in ARM:

| Mode        | Example                  | Description |
|-------------|--------------------------|-------------|
| Immediate   | `MOV R0, #15`             | Constant operand |
| Register    | `MOV R0, R1`              | Operand in register |
| Direct      | `LDR R0, VALUE`           | Value from memory label |
| Indirect    | `LDR R0, [R1]`            | Value from address in register |
| Pre-Indexed Without Update | `LDR R0, [R1, #4]`       | Add offset before load (no update) |
| Pre-indexed | `LDR R0, [R1, #4]!`       | Add offset before load (update pointer) |
| Post-indexed| `LDR R0, [R1], #4`        | Add offset after load |
| Register Indexed | `LDR R0, [R1, R2]`        | Base + register index |



## Examples

### Example 1: Looping Through an Array and a String

This program:
1. Loops through an integer array using a **length counter** (pre-known size).
2. Loops through a string until a **null terminator** is reached.

<<< @/snippets/assembly/exp2/example1.asm

### Example 2 - Case Conversion of a Null-Terminated String
This program converts a null-terminated string to uppercase.

<<< @/snippets/assembly/exp2/example2.asm




## Tasks
### Task 1 - Sum All Even Numbers in an Array
- Write an ARM assembly program to sum all even integers from an array.

### Task 2 - Count the Number of Vowels in a String
- Write an ARM assembly program to count the number of vowels (a, e, i, o, u) in a null-terminated string.
