---
outline: deep
lastUpdated: true
prev: false
---

# Introduction to ARM Assembly & Basic Data Processing Instructions

In this experiment, we will learn how to write ARM assembly programs using **Keil uVision5**, understand basic assembly syntax, and use core data processing instructions such as `MOV`, `ADD`, `SUB`, and simple shifts.

---

## Setting Up Keil uVision5

We will be using Keil uVision5 for this course.  
Download it here: [Keil uVision5](https://www.keil.com/demo/eval/arm.htm)

After installation, create a new project:

1. Open **Keil uVision5**  
2. **Project → New uVision Project**  
3. Select a new, empty folder for your project  
4. Name the project and click **Save**  
5. Choose device **ARM Cortex-M4 (ARMCM4)** → **OK**  
6. Right-click on *Source Group 1* → **Add New Item to Group** → select *Asm File*, give it a name → **Add**  
7. Right-click on *Target 1* → **Options for Target** → Debug tab → **Use Simulator**  
8. Build your project (**F7**) and start/stop debugging (**Ctrl + F5**).

::: tip
Always build before debugging. Debugging without building may run outdated code.
:::

---

## ARM Assembly Syntax

The ARM assembly language is a low-level language for ARM processors.  
Its syntax consists of **directives**, **instructions**, and **labels**.

**Directives** are for the assembler (e.g., defining sections, allocating memory).  
**Instructions** tell the CPU what to do.  
**Labels** are used to mark positions in the code.

### Common Directives

| Directive  | Description |
| ---------- | ----------- |
| `PRESERVE8` | Ensures the stack is 8-byte aligned. |
| `THUMB`     | Generate Thumb (16-bit) instructions. |
| `AREA`      | Defines a section in memory. |
| `EXPORT`    | Makes a label available to other files. |
| `DCD`/`DCW`/`DCB` | Define 32-bit/16-bit/8-bit constants. |
| `ALIGN`     | Aligns the next data/instruction to memory boundaries. |
| `ENTRY`     | Marks the program entry point. |
| `END`       | Marks the end of the program. |

---

## Registers Overview

ARM has **16 general-purpose registers** (`R0`–`R15`) and a **CPSR** status register.

| Register | Purpose |
| -------- | ------- |
| `R0`–`R12` | General use |
| `R13` (SP) | Stack Pointer |
| `R14` (LR) | Link Register |
| `R15` (PC) | Program Counter |

---

## Basic Data Processing Instructions

### Arithmetic
| Mnemonic | Syntax              | Description |
| -------- | ------------------- | ----------- |
| `ADD`    | `ADD Rd, Rn, Rm`    | Rd = Rn + Rm |
| `SUB`    | `SUB Rd, Rn, Rm`    | Rd = Rn - Rm |
| `MUL`    | `MUL Rd, Rn, Rm`    | Rd = Rn × Rm | 
| `UMULL`   | `UMULL RdL, RdH, Rn, Rm`   | {RdH, RdL} = Rn × Rm (long) |
| `SDIV`    | `SDIV Rd, Rn, Rm`   | Rd = Rn ÷ Rm (signed) |
| `UDIV`   | `UDIV Rd, Rn, Rm`   | Rd = Rn ÷ Rm (unsigned) |

### Logical
| Mnemonic | Syntax              | Description |
| -------- | ------------------- | ----------- |
| `AND`    | `AND Rd, Rn, Rm`    | Bitwise AND |
| `ORR`    | `ORR Rd, Rn, Rm`    | Bitwise OR |
| `EOR`    | `EOR Rd, Rn, Rm`    | Bitwise XOR |
| `BIC`    | `BIC Rd, Rn, Rm`    | Bitwise AND NOT (Bit Clear) |
| `MVN`    | `MVN Rd, Rn`        | Bitwise NOT |
| `TST`    | `TST Rn, Rm`        | Exclusive OR test |
| `TEQ`    | `TEQ Rn, Rm`        | AND test |



### Move
| Mnemonic | Syntax                 | Description |
| -------- | ---------------------- | ----------- |
| `MOV`    | `MOV Rd, #imm`         | Move immediate value to Rd |
| `MOVT`   | `MOVT Rd, #imm16`      | Move top 16 bits of a 32-bit value |
| `LDR`    | `LDR Rd, =value`       | Load an immediate or address into Rd |
| `STR`    | `STR Rn, [Rm]`         | Store Rn at the address in Rm |


### Shift
| Mnemonic | Syntax                 | Description |
| -------- | ---------------------- | ----------- |
| `LSL`    | `LSL Rd, Rm, #n`       | Logical Shift Left |
| `LSR`    | `LSR Rd, Rm, #n`       | Logical Shift Right |
| `ASR`    | `ASR Rd, Rm, #n`       | Arithmetic Shift Right |
| `ROR`    | `ROR Rd, Rm, #n`       | Rotate Right |
| `RRX`    | `RRX Rd, Rm`           | Rotate Right with Extend |

::: tip
The above instructions are a small subset of ARM assembly instructions. You can find the complete instruction set in the [Arm Cortex-M4 Technical Reference Manual](https://documentation-service.arm.com/static/5f19da2a20b7cf4bc524d99a).
:::

---
## Examples

### Example 1 - Arethmetic and Bitwise Operations

```
    AREA  RESET, DATA, READONLY
    EXPORT __Vectors
__Vectors
    DCD 0x20001000
    DCD Reset_Handler
    ALIGN

; Data section
NUM1    DCD 50              ; First integer
NUM2    DCD 12              ; Second integer
RP      DCD RESULT          ; Pointer to RESULT variable

    AREA MYDATA, DATA, READWRITE
RESULT  DCD 0               ; Will hold the final computed value

    AREA MYCODE, CODE, READONLY
    ENTRY
    EXPORT Reset_Handler

Reset_Handler
    ; Load values from memory into registers
    LDR R1, NUM1            ; R1 = 50
    LDR R2, NUM2            ; R2 = 12

    ; Perform arithmetic
    ADD R3, R1, R2          ; R3 = 50 + 12 = 62
    SUB R3, R3, #4          ; R3 = 62 - 4 = 58
    MUL R4, R3, R2          ; R4 = 58 × 12 = 696

    ; Logical operations
    AND R5, R4, #0xFF       ; R5 = 696 & 0xFF = 0xB8 (184)
    ORR R5, R5, #0x01       ; R5 = 0xB8 | 0x01 = 0xB9 (185)
    BIC R5, R5, #0x08       ; R5 = 0xB9 & ~0x08 = 0xB1 (177)
    EOR R5, R5, #0x02       ; R5 = 0xB1 ^ 0x02 = 0xB3 (179)

    ; Store result in memory using a pointer
    LDR R6, RP              ; R6 = address of RESULT
    STR R5, [R6]            ; RESULT = R5

    ; Read back for verification
    LDR R7, [R6]            ; R7 = RESULT

    END
```

### Example 2 - Status Flags and Logical Test
```asm
    AREA RESET, DATA, READONLY
    EXPORT __Vectors
__Vectors
    DCD 0x20001000
    DCD Reset_Handler
    ALIGN

    AREA MYCODE, CODE, READONLY
    ENTRY
    EXPORT Reset_Handler

Reset_Handler
    ; Set up registers
    MOVS R0, #10         ; R0 = 10, updates flags (N=0, Z=0)
    MOVS R1, #10         ; R1 = 10, updates flags

    ; Compare R0 and R1 using SUBS (R0 - R1)
    SUBS R2, R0, R1      ; R2 = 10 - 10 = 0
    ; Flags after SUBS:
    ; Z=1 (result zero), N=0, C=1 (no borrow), V=0

    ; Compare with immediate using TST (bitwise AND, updates flags)
    MOV R3, #0x0F        ; R3 = 0x0F (binary 00001111)
    TST R3, #0x08        ; Test bit 3
    ; Flags:
    ; Z=0 (bit 3 is set), N=0

    TST R3, #0x10        ; Test bit 4
    ; Flags:
    ; Z=1 (bit 4 not set), N=0

    ; Test equivalence using TEQ (bitwise XOR, updates flags)
    MOV R4, #0x55        ; 0x55 = 01010101b
    MOV R5, #0x55        ; same value
    TEQ R4, R5           ; R4 XOR R5 = 0
    ; Flags:
    ; Z=1 (equal), N=0

    MOV R6, #0x33        ; 0x33 = 00110011b
    TEQ R4, R6           ; 0x55 XOR 0x33 != 0
    ; Flags:
    ; Z=0, N=0

    ; Negative result example with ADDS
    MOVS R7, #5          ; R7 = 5
    SUBS R7, R7, #10     ; R7 = 5 - 10 = -5 (two’s complement)
    ; Flags:
    ; N=1 (negative), Z=0, C=0, V=0

    END
```