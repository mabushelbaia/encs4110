---
outline: deep
lastUpdated: true
prev: false
---
#  Data Processing and Status Flags

In this experiment, we will learn how to write ARM assembly programs using **Keil uVision5**, understand basic assembly syntax, and use core data processing instructions such as `MOV`, `ADD`, `SUB`, and simple shifts.


## Setting Up Keil uVision5

We will be using Keil uVision5 for this course.  
Download it here: [Keil uVision5](https://www.keil.com/demo/eval/arm.htm)

After installation, create a new project:

1. Open **Keil uVision5**  
2. **Project → New uVision Project**  
3. Select a new, empty folder for your project  
4. Name the project and click **Save**  
5. Choose device **ARM Cortex-M4 (ARMCM4)** → **OK**  
6. Right-click on *Source Group 1* → **Add New Item to Group** → select *Asm File*, give it a name → **Add**  
7. Right-click on *Target 1* → **Options for Target** → Debug tab → **Use Simulator**  
8. Build your project (**F7**) and start/stop debugging (**Ctrl + F5**).

::: tip
Always build before debugging. Debugging without building may run outdated code.
:::


## ARM Assembly Syntax

The ARM assembly language is a low-level language for ARM processors.  
Its syntax consists of **directives**, **instructions**, and **labels**.

- **Directives** are for the assembler (e.g., defining sections, allocating memory).  
- **Instructions** tell the CPU what to do.  
- **Labels** are used to mark positions in the code.

### Common Directives

| Directive  | Description |
| ---------- | ----------- |
| `PRESERVE8` | Ensures the stack is 8-byte aligned. |
| `THUMB`     | Generate Thumb (16-bit) instructions. |
| `AREA`      | Defines a section in memory. |
| `EXPORT`    | Makes a label available to other files. |
| `DCD`/`DCW`/`DCB` | Define 32-bit/16-bit/8-bit constants. |
| `ALIGN`     | Aligns the next data/instruction to memory boundaries. |
| `ENTRY`     | Marks the program entry point. |
| `END`       | Marks the end of the program. |


## Registers Overview

ARM has **16 general-purpose registers** (`R0`–`R15`) and a **CPSR** status register.

| Register | Purpose |
| -------- | ------- |
| `R0`–`R12` | General use |
| `R13` (SP) | Stack Pointer |
| `R14` (LR) | Link Register |
| `R15` (PC) | Program Counter |

### Status Register (CPSR)

The **Current Program Status Register (CPSR)** holds important information about the state of the processor, including:

- **Condition Flags**: Indicate the results of operations (N, Z, C, V). 
  - **N**: Negative (set if the result is negative)
  - **Z**: Zero (set if the result is zero)
  - **C**: Carry (set if there was a carry out of the most significant bit)
  - **V**: Overflow (set if there was an overflow in signed arithmetic)
- **Mode Bits**: Indicate the current processor mode (User, FIQ, IRQ, Supervisor, Abort, Undefined, System).
- **Interrupt Disable Bits**: Control the enabling/disabling of interrupts.

## Basic Data Processing Instructions

### Arithmetic
| Mnemonic | Syntax              | Description |
| -------- | ------------------- | ----------- |
| `ADD`    | `ADD Rd, Rn, Rm`    | Rd = Rn + Rm |
| `SUB`    | `SUB Rd, Rn, Rm`    | Rd = Rn - Rm |
| `MUL`    | `MUL Rd, Rn, Rm`    | Rd = Rn × Rm | 
| `UMULL`   | `UMULL RdL, RdH, Rn, Rm`   | {RdH, RdL} = Rn × Rm (long) |
| `SDIV`    | `SDIV Rd, Rn, Rm`   | Rd = Rn ÷ Rm (signed) |
| `UDIV`   | `UDIV Rd, Rn, Rm`   | Rd = Rn ÷ Rm (unsigned) |

### Logical
| Mnemonic | Syntax              | Description |
| -------- | ------------------- | ----------- |
| `AND`    | `AND Rd, Rn, Rm`    | Bitwise AND |
| `ORR`    | `ORR Rd, Rn, Rm`    | Bitwise OR |
| `EOR`    | `EOR Rd, Rn, Rm`    | Bitwise XOR |
| `BIC`    | `BIC Rd, Rn, Rm`    | Bitwise AND NOT (Bit Clear) |
| `MVN`    | `MVN Rd, Rn`        | Bitwise NOT |
| `TST`    | `TST Rn, Rm`        | Exclusive OR test |
| `TEQ`    | `TEQ Rn, Rm`        | AND test |



### Data Transfer
| Mnemonic | Syntax                 | Description |
| -------- | ---------------------- | ----------- |
| `MOV`    | `MOV Rd, #imm`         | Move immediate value to Rd |
| `MOVT`   | `MOVT Rd, #imm16`      | Move top 16 bits of a 32-bit value |
| `LDR`    | `LDR Rd, =value`       | Load an immediate or address into Rd |
| `STR`    | `STR Rn, [Rm]`         | Store Rn at the address in Rm |


### Shift/Rotate
| Mnemonic | Syntax                 | Description |
| -------- | ---------------------- | ----------- |
| `LSL`    | `LSL Rd, Rm, #n`       | Logical Shift Left |
| `LSR`    | `LSR Rd, Rm, #n`       | Logical Shift Right |
| `ASR`    | `ASR Rd, Rm, #n`       | Arithmetic Shift Right |
| `ROR`    | `ROR Rd, Rm, #n`       | Rotate Right |
| `RRX`    | `RRX Rd, Rm`           | Rotate Right with Extend |

::: tip
The above instructions are a small subset of ARM assembly instructions. You can find the complete instruction set in the [Arm Cortex-M4 Technical Reference Manual](https://documentation-service.arm.com/static/5f19da2a20b7cf4bc524d99a).
:::


## ARM Instruction Format

Most ARM data-processing instructions follow a common pattern:

```asm
[LABEL]  OPCODE{<cond>}{S}  Rd, Rn, Operand2
```

Where:
- `LABEL` – Optional name for the instruction location.
- `OPCODE` – Instruction mnemonic (e.g., ADD, SUB, MOV, CMP, etc.).
- `<cond>` – Optional 2-letter condition code (e.g., EQ, NE, GT).
    If omitted, the instruction is always executed.
- `S` – Optional suffix meaning "update flags" (sets N, Z, C, V flags).
- `Rd` – Destination register.
- `Rn` – First operand register (often the source for load/store).
- `Operand2` – Second operand; can be immediate, register, or register with barrel shift.

### Barrel Shifter

ARM provides a barrel shifter that can be used as a third operand in data processing instructions.
- **Logical Shift Left (LSL)**: Shifts bits to the left, filling with zeros.
- **Logical Shift Right (LSR)**: Shifts bits to the right, filling with zeros.
- **Arithmetic Shift Right (ASR)**: Shifts bits to the right, preserving the sign bit.
- **Rotate Right (ROR)**: Rotates bits to the right, with the rightmost bit wrapping around to the left.
- **Rotate Right with Extend (RRX)**: Rotates bits to the right, with the carry flag becoming the new leftmost bit.

**Syntax**: The barrel shifter can be used in the following way:

```asm
MOV R0, R1, LSL #2  ; Logical Shift Left (R0 <- R1 << 2)
MOV R0, R1, LSR #2  ; Logical Shift Right (R0 <- R1 >> 2)
MOV R0, R1, ASR #2  ; Arithmetic Shift Right (R0 <- R1 >> 2)
MOV R0, R1, ROR #2  ; Rotate Right (R0 <- R1 rotated right by 2)
MOV R0, R1, RRX     ; Rotate Right with Extend (R0 <- R1 rotated right with carry)
```

## Examples

### Example 1 - Arethmetic and Bitwise Operations
This example demonstrates basic arithmetic and bitwise operations in ARM assembly, how to set, clear, and flip bits.

<<< @/snippets/assembly/exp1/example1.asm


### Example 2 - Status Flags and Logical Test
This example demonstrates the use of status flags and logical tests in ARM assembly.

<<< @/snippets/assembly/exp1/example2.asm


## Tasks
### Task 1 - Bitwise Operations
Write an ARM assembly program that manipulates the contents of a register using bitwise operations (AND, OR, NOT, XOR) starting with Register R0 containing the value `0x0BADC0DE`.
- Clear bits 7-13 (inclusive)
- Set bits 17-23 (inclusive)
- Flip bits 24-31 (inclusive)

### Task 2 - Arithmetic Operations
Write an ARM assembly program that performs the following arithmetic operations:
Assume R0 = 10 and R1 = 5
- Add the values in R0 and R1, store the result in R2.
- Subtract the value in R1 from R0, store the result in R3.
- Multiply the values in R0 and R1, store the result in R4.
- Divide the value in R0 by R1, store the result in R5 (use unsigned division).
- Using barrel shifter only, find the multiplication of R0 by 9.
