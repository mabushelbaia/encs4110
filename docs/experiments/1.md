---
outline: deep
lastUpdated: true
prev: false
---
#  Data Processing and Status Flags

In this experiment, we will learn how to write ARM assembly programs using **Keil uVision5**, understand basic assembly syntax, and use core data processing instructions such as `MOV`, `ADD`, `SUB`, and simple shifts.


## Setting Up Keil uVision5

We will be using Keil uVision5 for this course.  
Download it here: [Keil uVision5](https://www.keil.com/demo/eval/arm.htm)

After installation, create a new project:

1. Open **Keil uVision5**  
2. **Project → New uVision Project**  
3. Select a new, empty folder for your project  
4. Name the project and click **Save**  
5. Choose device **ARM Cortex-M4 (ARMCM4)** → **OK**  
6. Right-click on *Source Group 1* → **Add New Item to Group** → select *Asm File*, give it a name → **Add**  
7. Right-click on *Target 1* → **Options for Target** → Debug tab → **Use Simulator**  
8. Build your project (**F7**) and start/stop debugging (**Ctrl + F5**).

::: tip
Always build before debugging. Debugging without building may run outdated code.
:::


## ARM Assembly Syntax

The ARM assembly language is a low-level language for ARM processors.  
Its syntax consists of **directives**, **instructions**, and **labels**.

- **Directives** are for the assembler (e.g., defining sections, allocating memory).  
- **Instructions** tell the CPU what to do.  
- **Labels** are used to mark positions in the code.

### Common Directives

| Directive  | Description |
| ---------- | ----------- |
| `PRESERVE8` | Ensures the stack is 8-byte aligned. |
| `THUMB`     | Generate Thumb (16-bit) instructions. |
| `AREA`      | Defines a section in memory. |
| `EXPORT`    | Makes a label available to other files. |
| `DCD`/`DCW`/`DCB` | Define 32-bit/16-bit/8-bit constants. |
| `ALIGN`     | Aligns the next data/instruction to memory boundaries. |
| `ENTRY`     | Marks the program entry point. |
| `END`       | Marks the end of the program. |


## Registers Overview

ARM has **16 general-purpose registers** (`R0`–`R15`) and a **CPSR** status register.

| Register | Purpose |
| -------- | ------- |
| `R0`–`R12` | General use |
| `R13` (SP) | Stack Pointer |
| `R14` (LR) | Link Register |
| `R15` (PC) | Program Counter |

### Status Register (CPSR)

The **Current Program Status Register (CPSR)** holds important information about the state of the processor, including:

- **Condition Flags**: Indicate the results of operations (N, Z, C, V). 
  - **N**: Negative (set if the result is negative)
  - **Z**: Zero (set if the result is zero)
  - **C**: Carry (set if there was a carry out of the most significant bit)
  - **V**: Overflow (set if there was an overflow in signed arithmetic)
- **Mode Bits**: Indicate the current processor mode (User, FIQ, IRQ, Supervisor, Abort, Undefined, System).
- **Interrupt Disable Bits**: Control the enabling/disabling of interrupts.

## Basic Data Processing Instructions

### Arithmetic
| Mnemonic | Syntax              | Description |
| -------- | ------------------- | ----------- |
| `ADD`    | `ADD Rd, Rn, Rm`    | Rd = Rn + Rm |
| `SUB`    | `SUB Rd, Rn, Rm`    | Rd = Rn - Rm |
| `MUL`    | `MUL Rd, Rn, Rm`    | Rd = Rn × Rm | 
| `UMULL`   | `UMULL RdL, RdH, Rn, Rm`   | {RdH, RdL} = Rn × Rm (long) |
| `SDIV`    | `SDIV Rd, Rn, Rm`   | Rd = Rn ÷ Rm (signed) |
| `UDIV`   | `UDIV Rd, Rn, Rm`   | Rd = Rn ÷ Rm (unsigned) |

### Logical
| Mnemonic | Syntax              | Description |
| -------- | ------------------- | ----------- |
| `AND`    | `AND Rd, Rn, Rm`    | Bitwise AND |
| `ORR`    | `ORR Rd, Rn, Rm`    | Bitwise OR |
| `EOR`    | `EOR Rd, Rn, Rm`    | Bitwise XOR |
| `BIC`    | `BIC Rd, Rn, Rm`    | Bitwise AND NOT (Bit Clear) |
| `MVN`    | `MVN Rd, Rn`        | Bitwise NOT |
| `TST`    | `TST Rn, Rm`        | Exclusive OR test |
| `TEQ`    | `TEQ Rn, Rm`        | AND test |



### Data Transfer
| Mnemonic | Syntax                 | Description |
| -------- | ---------------------- | ----------- |
| `MOV`    | `MOV Rd, #imm`         | Move immediate value to Rd |
| `MOVT`   | `MOVT Rd, #imm16`      | Move top 16 bits of a 32-bit value |
| `LDR`    | `LDR Rd, =value`       | Load an immediate or address into Rd |
| `STR`    | `STR Rn, [Rm]`         | Store Rn at the address in Rm |


### Shift/Rotate
| Mnemonic | Syntax                 | Description |
| -------- | ---------------------- | ----------- |
| `LSL`    | `LSL Rd, Rm, #n`       | Logical Shift Left |
| `LSR`    | `LSR Rd, Rm, #n`       | Logical Shift Right |
| `ASR`    | `ASR Rd, Rm, #n`       | Arithmetic Shift Right |
| `ROR`    | `ROR Rd, Rm, #n`       | Rotate Right |
| `RRX`    | `RRX Rd, Rm`           | Rotate Right with Extend |

::: tip
The above instructions are a small subset of ARM assembly instructions. You can find the complete instruction set in the [Arm Cortex-M4 Technical Reference Manual](https://documentation-service.arm.com/static/5f19da2a20b7cf4bc524d99a).
:::


## ARM Instruction Format

Most ARM data-processing instructions follow a common pattern:

```asm
[LABEL]  OPCODE{<cond>}{S}  Rd, Rn, Operand2
```

Where:
- `LABEL` – Optional name for the instruction location.
- `OPCODE` – Instruction mnemonic (e.g., ADD, SUB, MOV, CMP, etc.).
- `<cond>` – Optional 2-letter condition code (e.g., EQ, NE, GT).
    If omitted, the instruction is always executed.
- `S` – Optional suffix meaning "update flags" (sets N, Z, C, V flags).
- `Rd` – Destination register.
- `Rn` – First operand register (often the source for load/store).
- `Operand2` – Second operand; can be immediate, register, or register with barrel shift.

### Barrel Shifter

ARM provides a barrel shifter that can be used as a third operand in data processing instructions.
- **Logical Shift Left (LSL)**: Shifts bits to the left, filling with zeros.
- **Logical Shift Right (LSR)**: Shifts bits to the right, filling with zeros.
- **Arithmetic Shift Right (ASR)**: Shifts bits to the right, preserving the sign bit.
- **Rotate Right (ROR)**: Rotates bits to the right, with the rightmost bit wrapping around to the left.
- **Rotate Right with Extend (RRX)**: Rotates bits to the right, with the carry flag becoming the new leftmost bit.

**Syntax**: The barrel shifter can be used in the following way:

```asm
MOV R0, R1, LSL #2  ; Logical Shift Left (R0 <- R1 << 2)
MOV R0, R1, LSR #2  ; Logical Shift Right (R0 <- R1 >> 2)
MOV R0, R1, ASR #2  ; Arithmetic Shift Right (R0 <- R1 >> 2)
MOV R0, R1, ROR #2  ; Rotate Right (R0 <- R1 rotated right by 2)
MOV R0, R1, RRX     ; Rotate Right with Extend (R0 <- R1 rotated right with carry)
```

## Examples

### Example 1 - Arethmetic and Bitwise Operations
This example demonstrates basic arithmetic and bitwise operations in ARM assembly, how to set, clear, and flip bits.

```asm
    AREA  RESET, DATA, READONLY
    EXPORT __Vectors
__Vectors
    DCD 0x20001000
    DCD Reset_Handler
    ALIGN

; Data section
NUM1    DCD 50              ; First integer
NUM2    DCD 12              ; Second integer
RP      DCD RESULT          ; Pointer to RESULT variable

    AREA MYDATA, DATA, READWRITE
RESULT  DCD 0               ; Will hold the final computed value

    AREA MYCODE, CODE, READONLY
    ENTRY
    EXPORT Reset_Handler

Reset_Handler
    ; Load values from memory into registers
    LDR R1, NUM1            ; R1 = 50
    LDR R2, NUM2            ; R2 = 12

    ; Perform arithmetic
    ADD R3, R1, R2          ; R3 = 50 + 12 = 62
    SUB R3, R3, #4          ; R3 = 62 - 4 = 58
    MUL R4, R3, R2          ; R4 = 58 × 12 = 696

    ; Logical operations
    AND R5, R4, #0xFF       ; R5 = 696 & 0xFF = 0xB8 (184)
    ORR R5, R5, #0x01       ; R5 = 0xB8 | 0x01 = 0xB9 (185)
    BIC R5, R5, #0x08       ; R5 = 0xB9 & ~0x08 = 0xB1 (177)
    EOR R5, R5, #0x02       ; R5 = 0xB1 ^ 0x02 = 0xB3 (179)

    ; Store result in memory using a pointer
    LDR R6, RP              ; R6 = address of RESULT
    STR R5, [R6]            ; RESULT = R5

    ; Read back for verification
    LDR R7, [R6]            ; R7 = RESULT
STOP    B STOP

    END
```

### Example 2 - Status Flags and Logical Test
This example demonstrates the use of status flags and logical tests in ARM assembly.
```asm
    AREA RESET, DATA, READONLY
    EXPORT __Vectors
__Vectors
    DCD 0x20001000
    DCD Reset_Handler
    ALIGN

    AREA MYCODE, CODE, READONLY
    ENTRY
    EXPORT Reset_Handler

Reset_Handler
    ; Set up registers
    MOVS R0, #10         ; R0 = 10, updates flags (N=0, Z=0)
    MOVS R1, #10         ; R1 = 10, updates flags

    ; Compare R0 and R1 using SUBS (R0 - R1)
    SUBS R2, R0, R1      ; R2 = 10 - 10 = 0
    ; Flags after SUBS:
    ; Z=1 (result zero), N=0, C=1 (no borrow), V=0

    ; Compare with immediate using TST (bitwise AND, updates flags)
    MOV R3, #0x0F        ; R3 = 0x0F (binary 00001111)
    TST R3, #0x08        ; Test bit 3
    ; Flags:
    ; Z=0 (bit 3 is set), N=0

    TST R3, #0x10        ; Test bit 4
    ; Flags:
    ; Z=1 (bit 4 not set), N=0

    ; Test equivalence using TEQ (bitwise XOR, updates flags)
    MOV R4, #0x55        ; 0x55 = 01010101b
    MOV R5, #0x55        ; same value
    TEQ R4, R5           ; R4 XOR R5 = 0
    ; Flags:
    ; Z=1 (equal), N=0

    MOV R6, #0x33        ; 0x33 = 00110011b
    TEQ R4, R6           ; 0x55 XOR 0x33 != 0
    ; Flags:
    ; Z=0, N=0

    ; Negative result example with ADDS
    MOVS R7, #5          ; R7 = 5
    SUBS R7, R7, #10     ; R7 = 5 - 10 = -5 (two’s complement)
    ; Flags:
    ; N=1 (negative), Z=0, C=0, V=0
STOP    B STOP
    END
```

## Tasks
### Task 1 - Bitwise Operations
Write an ARM assembly program that manipulates the contents of a register using bitwise operations (AND, OR, NOT, XOR) starting with Register R0 containing the value `0x0BADC0DE`.
- Clear bits 7-13 (inclusive)
- Set bits 17-23 (inclusive)
- Flip bits 24-31 (inclusive)

### Task 2 - Arithmetic Operations
Write an ARM assembly program that performs the following arithmetic operations:
Assume R0 = 10 and R1 = 5
- Add the values in R0 and R1, store the result in R2.
- Subtract the value in R1 from R0, store the result in R3.
- Multiply the values in R0 and R1, store the result in R4.
- Divide the value in R0 by R1, store the result in R5 (use unsigned division).
- Using barrel shifter only, find the multiplication of R0 by 9.
