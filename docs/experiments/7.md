---
outline: deep
lastUpdated: true
---

# Character LCD Display Interface

::: info Complete Lab Manual
For the complete experiment including learning objectives, theoretical background, and detailed explanations, download the PDF manual:
 [**Download Experiment 7 PDF**](https://raw.githubusercontent.com/mabushelbaia/encs4110/main/manual/encs4110_07.pdf)
:::


## Examples

### Example: Basic LCD Driver Implementation

![LCD Connection Schematic](/image-3.png)

The figure above shows the complete wiring diagram for connecting the 16×2 LCD module to the TM4C123 microcontroller using 4-bit mode. The connections are:
- **Power**: VDD to VBus, VSS to Ground, V0 to contrast potentiometer
- **Control**: RS to PB0, E to PB2, RW to Ground (write-only)
- **Data**: D4-D7 to PB4-PB7 respectively
- **Backlight**: A to VBus, K to Ground

The contrast potentiometer (typically 10kΩ) allows adjustment of the display visibility - rotating it changes the voltage on V0 pin between 0V and VDD.

The following code demonstrates a complete LCD driver in 4-bit mode with initialization, command/data transmission, and text display functions.

::: code-group
<<< @/snippets/lcd/lcd.h
<<< @/snippets/lcd/lcd.c
<<< @/snippets/lcd/main.c
::: 

### Code Explanation

**Initialization Sequence**

The `LCD_Init()` function implements the complete 4-bit initialization:
1. Enables GPIO PORTB clock and configures pins as outputs
2. Waits 50 ms for LCD power-on stabilization
3. Sends `0x03` (upper nibble) three times with delays (8-bit mode reset)
4. Sends `0x02` (upper nibble) to switch to 4-bit mode
5. Sends configuration commands: `0x28` (4-bit, 2 lines), `0x0C` (display on), `0x06` (entry mode), `0x01` (clear)

**Nibble Transmission**

The `LCD_SendNibble()` function:
- Masks out current data bits (PB4-PB7)
- Places the 4-bit nibble on PB4-PB7 (shifted left by 4)
- Generates enable pulse: delay → E high → delay → E low → delay

**Command vs. Data**
- `LCD_Command()`: Sets RS=0, sends upper nibble, sends lower nibble
- `LCD_Data()`: Sets RS=1, sends upper nibble, sends lower nibble

**Cursor Positioning**

The `LCD_SetCursor(row, col)` function calculates the DDRAM address:
```c
address = (row == 0) ? 0x80 + col : 0xC0 + col;
```
Then sends the address as a command.

**String Printing**

The `LCD_Print(str)` function iterates through the string and sends each character using `LCD_Data()`.

## Tasks

### Task 1: Display Your Name and ID

Update the main program to display your name on the first line and your student ID on the second line of the LCD.

**Requirements:**
- Clear the display
- Set cursor to line 1, column 0
- Print your name (up to 16 characters)
- Set cursor to line 2, column 0
- Print your student ID

**Hint:**
```c
LCD_Clear();
LCD_SetCursor(0, 0);  // Line 1
LCD_Print("Your Name");
LCD_SetCursor(1, 0);  // Line 2
LCD_Print("ID: 1234567");
```

### Task 2: Button-Controlled Name Scrolling

Write a program that displays your name on the LCD and allows the user to scroll the text left or right using the two on-board push buttons (SW1 and SW2).

**Requirements:**
- Display your name on line 1
- Configure SW1 (PF4) and SW2 (PF0) with GPIO interrupts (falling edge, internal pull-up)
- When SW1 is pressed: Shift display left (command `0x18`)
- When SW2 is pressed: Shift display right (command `0x1C`)
- The display should not scroll automatically; only respond to button presses

### Task 3: Bidirectional Continuous Scrolling

Write a program that displays your name on line 1 and your student ID on line 2, with continuous scrolling in opposite directions after a button press.

**Requirements:**
- Display your name on line 1 and ID on line 2
- Initially, the display is static (no scrolling)
- When SW1 is pressed, start continuous scrolling:
  - Line 1 scrolls right
  - Line 2 scrolls left
- Pressing SW1 again stops the scrolling
- Use a timer interrupt to handle the scrolling at a fixed interval (e.g., every 500 ms)
