---
outline: deep
lastUpdated: true
---

# Stack and Procedure Calls

The **stack** is a memory region used for temporary data storage such as return addresses, local variables, and register values during subroutine calls. ARM relies on software conventions to manage the stack, typically using the stack pointer register (`SP`, or `R13`).
## Stack
### Stack Growth and Pointer Meaning

* **Ascending vs. Descending:**

  * *Ascending stack* grows toward higher memory addresses; `SP` increases when pushing data.
  * *Descending stack* grows toward lower memory addresses; `SP` decreases when pushing data.

* **Full vs. Empty:**
  This indicates what the stack pointer (`SP`) points to:

  * *Full stack:* `SP` points to the **last stored item** (top of stack).
  * *Empty stack:* `SP` points to the **next free slot** where data will be pushed.

ARM Cortex-M uses a **Full Descending Stack** — the stack grows downward, and `SP` points to the most recently stored item.


### PUSH and POP Instructions

`PUSH` and `POP` let you efficiently save and restore multiple registers on the stack.

* **Register Order:**
Registers are stored on the stack in numerical order, with the lowest numbered register at the lowest address.

  ```asm
  PUSH {R3, R1, R2} 
  ```

  Although written as `{R3, R1, R2}`, ARM pushes in the order `R1`, `R2`, then `R3`. The lowest register (`R1`) is stored at the **lowest memory address** on the stack, and the highest (`R3`) at the highest address.





## Procedures (Subroutines)

### What is a Procedure?
A **Procedure** (also called a subroutine or function) is a named block of code designed to perform a specific task. Procedures allow you to:

- Organize code into reusable, modular units.
- Avoid repetition by calling the same code from multiple places.
- Simplify program structure and improve readability.

In ARM assembly, procedures are often marked using the assembler directives `PROC` and `ENDP`, which help the assembler identify the start and end of a procedure. Procedures are called using the BL (Branch with Link) instruction, which stores the return address in the link register `(LR, R14)`.

```asm
MyProc PROC
    ; Add 1 to R0
    ADD R0, R0, #1
    BX LR
ENDP
```

### Calling a Subroutine
When you call a subroutine using `BL label`, the return address (the instruction immediately following the call) is automatically saved in the **link register (`LR`, R14)**.

**To return from the subroutine, you have two common options:**

* `MOV PC, LR` — moves the return address from `LR` into the program counter, causing a return to the caller.
* **Preferably:** `BX LR` — branches to the address in `LR`, also handling a switch between ARM and Thumb instruction sets if necessary.

:::danger Important
Since the link register holds only one return address, if a subroutine itself calls another subroutine (nested calls), the original return address in `LR` will be overwritten. To avoid losing return information, the current value of `LR` should be saved on the stack (or another register) before making another subroutine call, and restored before returning.
:::

### Nested Subroutine Calls
When a subroutine calls another subroutine, the current value of `LR` (the return address) must be saved to avoid losing it. This is typically done by pushing `LR` onto the stack before making the nested call.

```asm

outerFunction
    PUSH {LR}           ; Save return address
    BL innerFunction    ; Call innerFunction
    POP {PC}            ; Restore return address

innerFunction
    ; Do something
    BX LR               ; Return from innerFunction

Reset_Handler
    BL outerFunction
    ; Continue execution after outerFunction returns

```
## ARM Procedure Call Standard (AAPCS) Summary

The ARM Architecture Procedure Call Standard (AAPCS) defines rules for function calls to ensure interoperability between different code modules and tools.

**Parameter Passing**

- The first four integer or pointer parameters are passed in registers **R0-R3**.
- Additional parameters are passed on the stack.

**Return Values**

- The primary return value is returned in **R0**.
- Larger or complex return values may use multiple registers or memory.

**Register Usage**

- **Caller-saved registers:** `R0-R3`, `R12`, `LR`  
  These may be overwritten by the called function, so the caller must save them if needed.

- **Callee-saved registers:** `R4-R11`, `SP (R13)`  
  The called function must preserve these if it uses them (typically by pushing/popping on the stack).

- **Stack Pointer (`SP` or `R13`):**  
  Points to the top of the stack. Must be preserved by the callee.

## Examples

### Example 1: Summation using a Procedure
This example demonstrates how to use a procedure to compute the sum of numbers from `1 => N`.

<<< @/snippets/assembly/exp3/example1.asm

### Example 2: Sum of Array Elements After Modulo Operation
This example demonstrates nested subroutine calls in ARM assembly. It computes the sum of an array of integers after applying a modulo operation to each element.


<<< @/snippets/assembly/exp3/example2.asm


## Tasks
### Task 1 - Count Vowels using Procedures
Extend the previous experiment to count the number of vowels in a string using procedures. Implement a procedure that takes a string pointer and returns the count of vowels in that string. The procedure should have the following signature:

```asm
CountVowels PROC
    ; Input: R0 - pointer to string
    ; Output: R0 - number of vowels
ENDP
```
> Preferably, the procedure should use nested procedures for character checking and counting.

### Task 2 - Recursive Factorial Calculation
Implement a recursive procedure to calculate the factorial of a number. A factorial of n (n!) is the product of all positive integers less than or equal to n. The procedure should have the following signature:

```asm
Factorial PROC
    ; Input: R0 - integer n
    ; Output: R0 - factorial of n
ENDP
```
> The procedure should use a base case for n = 0  and a recursive case for n > 0 .
