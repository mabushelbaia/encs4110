---
outline: deep
lastUpdated: true
---
# Interrupts and NVIC

## Introduction

In the previous experiment, we learned how to setup GPIO pins and used them to control LEDs. In this experiment, we will learn how to use GPIO pins as inputs (switches, sensors, etc.) and how to configure them to generate external interrupts. We will use the switches on the LaunchPad to generate interrupts and toggle the LEDs.

### Components

- Ek-TM4C123GXL LaunchPad
- USB A to Micro-B cable

## Switch Bouncing and Debouncing

When a mechanical switch is pressed or released, the contacts of the switch bounce before settling down. This bouncing can cause multiple interrupts to be generated for a single press or release event. To avoid this, we need to debounce the switch. Debouncing is the process of removing the noise caused by the bouncing of the switch contacts.

There are two ways to debounce a switch:

- **Hardware Debouncing**: In hardware debouncing, a capacitor is connected in parallel with the switch to filter out the noise.
- **Software Debouncing**: In software debouncing, we use a timer/delay to wait for a certain amount of time before reading the state of the switch.

In this experiment, we will use software debouncing to debounce the switches.

![alt text](/image.png)

## Switch configuration

The switches on the LaunchPad are connected to the GPIO pins of port F. We will configure the switches as inputs and enable the internal pull-up resistors. The internal pull-up resistors will pull the pins high when the switches are open. When the switches are closed, the pins will be pulled low, pulling the pin (high/low) is essential as a floating pin can cause false interrupts/readings.

### Registers used for switch configuration

1. **GPIODIR** GPIO Direction register: Used to set the direction of the pins in the port. Writing a 1 to a bit in the register will set the corresponding pin to output, and writing a 0 will set the pin to input.
2. **GPIODEN** GPIO Digital Enable register: Used to enable the digital functionality of the pins in the port. Writing a 1 to a bit in the register will enable the digital functionality of the corresponding pin, and writing a 0 will disable the digital functionality.
3. **GPIOPUR** GPIO Pull-Up register: Used to enable the internal pull-up resistors of the pins in the port. Writing a 1 to a bit in the register will enable the pull-up resistor of the corresponding pin, and writing a 0 will disable the pull-up resistor.
4. **GPIOPDR** GPIO Pull-Down register: Used to enable the internal pull-down resistors of the pins in the port. Writing a 1 to a bit in the register will enable the pull-down resistor of the corresponding pin, and writing a 0 will disable the pull-down resistor.

## External Interrupts

An external interrupt is an interrupt generated by an external device or peripheral. In this experiment, we will configure the GPIO pins connected to the switches as external interrupt sources. We will use the GPIO ports' interrupt registers to configure the pins to generate interrupts on the rising edge, falling edge, or both.

### Registers used for external interrupts

1. **GPIOIS** GPIO Interrupt Sense register: Used to set the interrupt detection type (level or edge) for the pins in the port. Writing a 1 to a bit in the register will set the corresponding pin to level-sensitive, and writing a 0 will set the pin to edge-sensitive.
2. **GPIOIBE** GPIO Interrupt Both Edges register: Used to enable interrupts on both edges of the pins in the port. Writing a 1 to a bit in the register will enable interrupts on both edges of the corresponding pin, and writing a 0 will disable interrupts on both edges.
3. **GPIOIEV** GPIO Interrupt Event register: Used to set the interrupt event type (rising or falling edge) for the pins in the port. Writing a 1 to a bit in the register will set the corresponding pin to rising edge, and writing a 0 will set the pin to falling edge.
4. **GPIOIM** GPIO Interrupt Mask register: Used to enable/disable interrupts for the pins in the port. Writing a 1 to a bit in the register will enable the interrupt for the corresponding pin, and writing a 0 will disable the interrupt.
5. **GPIOMIS** GPIO Masked Interrupt Status register: Used to read the masked interrupt status of the pins in the port. Reading 1 from a bit in the register indicates that the corresponding pin has caused an interrupt.
6. **GPIOICR** GPIO Interrupt Clear register: Used to clear the interrupt flag for the pins in the port. Writing a 1 to a bit in the register will clear the interrupt flag for the corresponding pin.
7. **NVICEN0** Nested Vector Interrupt Controller Enable register: Used to enable the interrupt in the Nested Vector Interrupt Controller (NVIC). Writing a 1 to a bit in the register will enable the interrupt in the NVIC. The port F interrupt is connected to the NVIC interrupt number 30.

### GPIO PINS with Special Considiration

The GPIOCR register has a built-in safeguard to prevent accidental reconfiguration of pins that are critical for NMI (Non-Maskable Interrupt) and JTAG/SWD (Serial Wire Debug) connectivity. By default, the NMI and JTAG/SWD pins in the GPIOCR register are set to 0, meaning they are protected from unintended modifications. To intentionally repurpose these pins for GPIO functionality, specific steps must be taken to write to the GPIOLOCK, GPIOCR, and associated registers (refer to the "Signal Tables" on page 1329 for the relevant pin numbers).

Since this protection applies only to the NMI and JTAG/SWD pins, the other bits in the GPIOCR registers are hardwired to 1. This ensures that you can always commit new values to control registers like GPIOAFSEL, GPIOPUR, GPIOPDR, and GPIODEN for non-critical pins without special unlocking steps.

If you need to unlock certain pins, such as GPIO pin 0 of port F, write 0x4C4F434B to the GPIOLOCK register. Then, set the appropriate GPIOCR register bit to 1 to enable configuration.

![alt text](/image-1.png)


## Examples

### Example 1: Reading input using Polling

<<< @/snippets/gpio/polling.c


### Example 2: External Interrupts

<<< @/snippets/gpio/interrupt.c

## Tasks 
### Task 1: Toggle LED using Polling
Modify Program 1 (using polling technique) to toggle the green LED with the press of a switch SW1.  
The switch on PF4 will be configured as input, and the LED on PF3 (green LED) will be used as output.  
At each press of the switch, the LED will toggle its present state — i.e., the LED will turn ON if it was OFF previously.

> **Note:** The needed time for the user to press the push button is approximately 200 ms.  
> The speed of the TM4C123G controller is very high, so the `while (true)` loop will be executed many times during this period (200 ms).  
> This means the button may appear to have been pressed many times, though the user pressed it only once.  
> Therefore, some delay is required after detecting a button click.

### Task 2: Led Sequence using Interrupts
Modify Program 2 (using the interrupt technique) so that pressing the onboard SW1 cycles the LEDs through the sequence **Red → Blue → Green** repeatedly.  
Additionally, configure the program so that pressing the other onboard switch cycles the LEDs through the sequence **Yellow → Magenta → Cyan** repeatedly.

