\chapter{ARM Cortex-M4 Instructions and Addressing Modes}
\section*{Learning Objectives}
After completing this experiment, you will be able to:
\begin{itemize}[nosep]
  \item Classify ARM Cortex-M4 instructions into data-processing, load/store, and branch categories.
  \item Perform arithmetic, logical, and shift/rotate operations using data-processing instructions (including \texttt{Operand2} with the barrel shifter).
  \item Move data between registers and memory using load/store instructions with immediate, register-offset, and pre-/post-indexed addressing modes.
  \item Declare and initialize data objects (arrays, strings, buffers) with assembler directives, and use pointers to access and modify them.
  \item Trace how instructions affect registers and xPSR flags using the \keil\ debugger (breakpoints, single-step, register/memory views).
\end{itemize}
\section*{Experiment Overview}
This experiment develops fluency with the ARM Cortex-M4 instruction set for data manipulation and memory access. 
You will practice using arithmetic, logical, and shift/rotate instructions, and learn how data moves between registers and memory through load/store instructions and their addressing modes. 
You will also define data with assembler directives and use pointers to read and update memory.

\noindent In this experiment, you will:
\begin{itemize}[nosep]
  \item Write and run short assembly routines that use data-processing instructions to transform register values.
  \item Apply immediate, register-offset, and pre-/post-indexed addressing modes to load from and store to memory.
  \item Define arrays, strings, and buffers with directives, and use pointers to traverse and modify them.
  \item Observe instruction effects on registers and flags with the \keil\ debugger to verify correctness.
\end{itemize}

By the end of this lab, you will be able to implement, assemble, and debug Cortex-M4 programs that perform register-level computation and structured memory access—providing the foundation for flow control and procedure calls in later experiments.

\newpage
\etocsetnexttocdepth{subsubsection}
\localtableofcontents
\bigskip
\newpage
\section{Theoretical Background}
As mentioned in Experiment 1, assembly instructions are split into three main categories: data processing, load/store, and branch instructions. This experiment focuses on data processing instructions, load/store instructions and their addressing modes. branch instructions and flow control will be covered in the next experiment.
\subsection{Data Processing Instructions}
Data processing instructions perform arithmetic and logical operations on data stored in registers. They can also manipulate the condition flags in the xPSR based on the results of the operations. Common data processing instructions take the following form:
\[
\begin{aligned}
\texttt{\{LABEL\}} \quad & \texttt{OPCODE\{<cond>\}\{S\} Rd, Rn, Operand2}
\end{aligned}
\]

where:
\begin{itemize}[nosep]
    \item \texttt{LABEL}: optional label for branching.
    \item \texttt{OPCODE}: the operation to be performed (e.g., \texttt{ADD}, \texttt{SUB}, \texttt{AND}, \texttt{ORR}).
    \item \texttt{<cond>}: optional condition code that predicates execution.
    \item \texttt{S}: optional suffix indicating whether to update the condition flags.
    \item \texttt{Rd}: destination register where the result is stored.
    \item \texttt{Rn}: first operand register.
    \item \texttt{Operand2}: second operand, which can be an immediate value limited to 8 bits, a register, or a barrel shifter operation (see Section~\ref{sec:barrel-shifter}).
\end{itemize}


\subsubsection{Arithmetic Instructions}
Arithmetic instructions perform basic mathematical operations. Some common arithmetic instructions include addition, subtraction, multiplication, and their variants. The following table summarizes some of the most commonly used arithmetic instructions in the ARM Cortex-M4 architecture.
\begin{table}[H]
\centering
\caption{Common ARM Cortex-M4 Arithmetic Instructions}
\small
\begin{tabularx}{\linewidth}{@{}l l l X@{}}
\toprule
\textbf{Instr.} & \textbf{Syntax} & \textbf{Operation} & \textbf{Description} \\
\midrule
ADD  & \texttt{ADD\{S\} Rd, Rn, Operand2}
     & $Rd \leftarrow Rn + Operand2$
     & \emph{Operand2} may be a register, an immediate, or a shifted register. \\
ADC  & \texttt{ADC\{S\} Rd, Rn, Operand2}
     & $Rd \leftarrow Rn + Operand2 + C$
     & Adds carry-in $C$. \\
SUB  & \texttt{SUB\{S\} Rd, Rn, Operand2}
     & $Rd \leftarrow Rn - Operand2$
     & Standard subtraction. \\
SBC  & \texttt{SBC\{S\} Rd, Rn, Operand2}
    & $Rd \leftarrow Rn - Operand2 - \overline{C}$
    & Subtract with carry. If carry flag is clear, result is reduced by one. Used for multiword arithmetic. \\
RSB  & \texttt{RSB\{S\} Rd, Rn, Operand2}
     & $Rd \leftarrow Operand2 - Rn$
     & Reverse subtract. \\
MUL  & \texttt{MUL\{S\} Rd, Rn, Rm}
     & $Rd \leftarrow (Rn \times Rm)_{[31{:}0]}$
     & 32$\times$32 $\rightarrow$ low 32 bits. \\
MLA  & \texttt{MLA Rd, Rn, Rm, Ra}
     & $Rd \leftarrow (Rn \times Rm) + Ra$
     & Multiply-accumulate. \\
MLS  & \texttt{MLS Rd, Rn, Rm, Ra}
     & $Rd \leftarrow Ra - (Rn \times Rm)$
     & Multiply-subtract. \\
UMULL & \texttt{UMULL RdLo, RdHi, Rn, Rm}
      & $\{RdHi,RdLo\} \leftarrow Rn \times Rm$
      & Unsigned 32$\times$32 $\rightarrow$ 64-bit product. \\
SMULL & \texttt{SMULL RdLo, RdHi, Rn, Rm}
      & $\{RdHi,RdLo\} \leftarrow Rn \times Rm$
      & Signed 32$\times$32 $\rightarrow$ 64-bit product. \\
\bottomrule
\end{tabularx}

\vspace{2pt}
\footnotesize\emph{Note:} $C$ denotes the carry flag in \texttt{xPSR}. \emph{Operand2} may be an immediate or a shifted register depending on the encoding.
\end{table} 
\subsubsection{Logical and Move Instructions}
Logical instructions perform bitwise operations on data, while move instructions transfer data between registers or load immediate values. The following table summarizes some of the most commonly used logical and move instructions in the ARM Cortex-M4 architecture.
\begin{table}[H]
\centering
\caption{Logical and Move Instructions}
\small
\begin{tabularx}{\linewidth}{@{}l l l X@{}}
\toprule
\textbf{Instr.} & \textbf{Syntax} & \textbf{Operation} & \textbf{Description} \\
\midrule
AND  & \texttt{AND Rd, Rn, Operand2} & $Rd \leftarrow Rn \,\&\, Operand2$ & Bitwise AND. \\
ORR  & \texttt{ORR Rd, Rn, Operand2} & $Rd \leftarrow Rn \,|\, Operand2$ & Bitwise OR. \\
EOR  & \texttt{EOR Rd, Rn, Operand2} & $Rd \leftarrow Rn \oplus Operand2$ & Bitwise XOR. \\
BIC  & \texttt{BIC Rd, Rn, Operand2} & $Rd \leftarrow Rn \,\&\, \neg Operand2$ & Bit clear. \\
MVN  & \texttt{MVN Rd, Operand2}     & $Rd \leftarrow \neg Operand2$ & Bitwise NOT of operand. \\
MOV  & \texttt{MOV Rd, Operand2}     & $Rd \leftarrow Operand2$ & Register or immediate move. \\
MOVW & \texttt{MOVW Rd, \#imm16}     & $Rd[15{:}0] \leftarrow imm16$ & Write low halfword. \\
MOVT & \texttt{MOVT Rd, \#imm16}     & $Rd[31{:}16] \leftarrow imm16$ & Write high halfword (low preserved). \\
\bottomrule
\end{tabularx}

\vspace{2pt}
\footnotesize\emph{Note:} $C$ denotes the carry flag in \texttt{xPSR}. \emph{Operand2} may be an immediate or a shifted register depending on the encoding.
\end{table}

In this experiment, you will work with bitwise logical instructions to manipulate individual bits within registers.
Such operations are fundamental in microcontroller programming, where control and status registers often contain multiple configuration fields packed into a single 32-bit word.
Understanding how to set, clear, toggle, or test specific bits without altering the rest of the register is essential for safely modifying hardware configurations and controlling peripherals.
\paragraph{Set and Clear Bits}
To set, clear, or toggle specific bits in a register, you can use the following logical instructions:
\begin{itemize}[nosep]
    \item \texttt{ORR Rd, Rn, \#mask}: Sets bits in \texttt{Rd} where the corresponding bits in \texttt{mask} are 1.
    \item \texttt{BIC Rd, Rn, \#mask}: Clears bits in \texttt{Rd} where the corresponding bits in \texttt{mask} are 1.
    \item \texttt{EOR Rd, Rn, \#mask}: Toggles bits in \texttt{Rd} where the corresponding bits in \texttt{mask} are 1.
\end{itemize}

BIC is essentially an AND operation with the negated mask, i.e., \texttt{BIC Rd, Rn, \#mask} is equivalent to \texttt{AND Rd, Rn, \#\textasciitilde{}mask}.\\

\paragraph{Check Bits}
To check whether certain bits are set or cleared, you can use the \texttt{AND} instruction followed by a comparison:
\begin{itemize}[nosep]
    \item \texttt{AND Rd, Rn, \#mask}: Isolates bits in \texttt{Rn} where the corresponding bits in \texttt{mask} are 1. The result is stored in \texttt{Rd}.
    \item You can then use \texttt{CMP Rd, \#0} to determine if the result is zero (all masked bits cleared) or non-zero (at least one bit set).
    \item Alternatively, you can use \texttt{TST Rn, \#mask}, which performs the AND operation and updates the condition flags without storing the result.
\end{itemize}

\noindent\textit{The \texttt{TST} instruction and its interaction with the condition flags will be explored in more detail in the next experiment, where you will learn how conditional execution and branching depend on flag states.}

\subsubsection{Shift and Rotate Instructions}
\begin{table}[H]
\centering
\caption{Shift and Rotate Instructions}
\small
\begin{tabularx}{\linewidth}{@{}l l l X@{}}
\toprule
\textbf{Instr.} & \textbf{Syntax} & \textbf{Operation} & \textbf{Description} \\
\midrule
LSL & \texttt{LSL Rd, Rm, \#sh\textbar Rs}
    & $Rd \leftarrow Rm \ll sh$
    & Logical left shift by immediate or by register. \\
LSR & \texttt{LSR Rd, Rm, \#sh\textbar Rs}
    & $Rd \leftarrow Rm \gg sh$
    & Logical right shift (zero fill). \\
ASR & \texttt{ASR Rd, Rm, \#sh\textbar Rs}
    & $Rd \leftarrow Rm \gg sh$
    & Arithmetic right shift (sign fill). \\
ROR & \texttt{ROR Rd, Rm, \#sh\textbar Rs}
    & $Rd \leftarrow \mathrm{ROR}(Rm, sh)$
    & Rotate right by immediate or by register. \\
RRX & \texttt{RRX Rd, Rm}
    & $Rd \leftarrow \mathrm{ROR}_{C}(Rm, 1)$
    & Rotate right 1 bit through carry (uses $C$ as incoming bit 31, outgoing bit 0 $\rightarrow C$). \\
\bottomrule
\end{tabularx}

\vspace{2pt}
\footnotesize\emph{Note:} Shift amount can be an immediate \texttt{\#sh} (0--31) or a register \texttt{Rs} (low 8 bits used). 
For immediates: \texttt{LSL \#0} = no shift; \texttt{LSR \#0} is treated as shift by 32; \texttt{ASR \#0} is treated as shift by 32; \texttt{ROR \#0} means \texttt{RRX}.
\end{table}
Not all shift/rotate instructions are explicitly present in the ARMv7-M ISA.\@ For example, there is no ROL (rotate left) or ASL (arithmetic shift left) instruction, as these operations can be achieved using existing shift instructions: ROL can be implemented using ROR with a complementary shift amount, and ASL is equivalent to LSL.

\subsubsection{Barrel Shifter}
\label{sec:barrel-shifter}

The barrel shifter is a hardware feature that allows for efficient shifting and rotating of register values as part of data processing instructions. It can perform operations such as logical shifts (left or right), arithmetic shifts, and rotations on the second operand (\texttt{Operand2}) before it is used in the instruction without wasting extra instructions or cycles.

\noindent Examples of barrel shifter usage:
\begin{lstlisting}[caption={Barrel shifter examples}]
    ADD    R0, R2, R1, LSL #2    ; R0 = R2 + (R1 << 2) using barrel shifter
    SUB    R3, R4, R5, LSR #1    ; R3 = R4 - (R5 >> 1) using barrel shifter
    ORR    R6, R7, R8, ROR #3    ; R6 = R7 | (R8 rotated right by 3)
\end{lstlisting}

\subsection{Load and Store Instructions}
Since the ARM Cortex-M4 follows the RISC design philosophy, it uses a load/store architecture.
This means that arithmetic and logical instructions operate only on registers.
Any data in memory must first be loaded into a register before processing, and results must be stored back to memory if they need to be preserved.

\begin{table}[H]
\centering
\caption{Load and Store Instructions (Summary)}
\small
\begin{tabularx}{\linewidth}{@{}l l X@{}}
\toprule
\textbf{Instr.} & \textbf{Syntax Example} & \textbf{Description} \\
\midrule
LDR / STR       & \texttt{LDR/STR Rt, [Rn, \#off]} & Load/store a 32-bit word. \\
LDRB / STRB     & \texttt{LDRB/STRB Rt, [Rn, \#off]} & Load/store an 8-bit byte. \\
LDRH / STRH     & \texttt{LDRH/STRH Rt, [Rn, \#off]} & Load/store a 16-bit halfword. \\
LDRSB / LDRSH   & \texttt{LDRSB/LDRSH Rt, [Rn, \#off]} & Load signed byte/halfword and sign-extend to 32 bits. \\
LDRD / STRD     & \texttt{LDRD/STRD Rt, Rt2, [Rn, \#off]} & Load/store a 64-bit doubleword (two registers). \\
\bottomrule
\end{tabularx}
\vspace{2pt}
\end{table}


\begin{lstlisting}[caption={Examples of Load and Store Instructions}]
Reset_Handler
        LDR     R0, =XVAL         ; R0 = &XVAL (address of XVAL)
        LDR     R1, [R0]          ; R1 = 0x12345678 (load word from memory)
        ADR     R5, XVAL          ; R5 = PC-relative address of XVAL (if in range)

        LDRB    R2, [R0]          ; R2 = 0x78 (lowest byte of XVAL)
        LDRH    R3, [R0]          ; R3 = 0x5678 (lowest halfword of XVAL)

        MOV     R4, #0xFF
        LDR     R0, YPTR          ; R0 = contents of YPTR = &YVAL
        STRB    R4, [R0]          ; store 0xFF into YVAL (low byte only)

STOP    B       STOP

        AREA    MYDATA, DATA, READONLY
XVAL    DCD     0x12345678        ; word in memory
YPTR    DCD     YVAL              ; contains the address of YVAL

        AREA    MYDATA2, DATA, READWRITE
YVAL    DCD     0

        END
\end{lstlisting}
\subsubsection{Loading Addresses and Values: \texttt{LDR}, \texttt{LDR =}, and \texttt{ADR}}

In ARM assembly, it is important to distinguish between loading a \emph{value} from memory and loading the \emph{address} of a label.  
Although these instructions look similar, their behavior and purpose differ depending on how the assembler interprets them.
\begin{itemize}[nosep]
    \item \textbf{\texttt{LDR Rn, label}}  
    Loads the 32-bit \emph{value} stored at the memory address identified by \texttt{label} into register \texttt{Rn}.  
    The CPU performs a direct memory read:
    \[
      \texttt{Rn} \leftarrow [\texttt{label}]
    \]
    Example: \texttt{LDR R0, XVAL} loads the contents of \texttt{XVAL} (e.g., \texttt{0x12345678}) into \texttt{R0}.
    
    \item \textbf{\texttt{LDR Rn, =label}}  
    Loads the \emph{address} of \texttt{label} into \texttt{Rn}, rather than the data stored at that address.  
    The assembler generates this by either constructing the address using \texttt{MOVW/MOVT} instructions or placing it in a nearby \emph{literal pool} for PC-relative loading.\footnote{For more details, see ARM Developer Documentation, “Literal pools and \texttt{LDR =const}”. \url{https://developer.arm.com/documentation/dui0473/m/dom1359731147760}}  
    \[
      \texttt{Rn} \leftarrow \texttt{\&label}
    \]
    Example: \texttt{LDR R0, =XVAL} places the address of \texttt{XVAL} in \texttt{R0}.
    
    \item \textbf{\texttt{ADR Rn, label}}  
    Loads the \emph{address} of \texttt{label} into \texttt{Rn} by computing it relative to the current program counter.  
    This method requires no literal pool or memory access but only works for nearby addresses (about $\pm$4~KB in Thumb mode):  
    \[
      \texttt{Rn} \leftarrow \texttt{PC} + \texttt{offset(label)}
    \]
\end{itemize}



\subsubsection{Understanding Pointer Declarations}
The directive \texttt{YPTR DCD YVAL} reserves a 32-bit word at the label \texttt{YPTR} and initializes it with the address of \texttt{YVAL}.  
In other words, \texttt{YPTR} acts as a \emph{pointer variable} that holds the address of another variable (\texttt{YVAL}).  
Executing \texttt{LDR Rn, YPTR} loads the 32-bit contents stored at \texttt{YPTR}—that is, the address of \texttt{YVAL}—into \texttt{Rn}, making \texttt{Rn} a pointer to \texttt{YVAL}.


\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Address} & \textbf{Label} & \textbf{Contents} \\
\hline
0x2000 & XVAL & 0x12345678 \\
0x2004 & YPTR & 0x2008 (address of YVAL) \\
0x2008 & YVAL & 0x00000000 \\
\hline
\end{tabular}
\end{center}
\subsubsection{Declaring Arrays and Strings}

Data in assembly is defined using \emph{assembler directives} that reserve and optionally initialize memory.  
Common directives include \texttt{DCD}, \texttt{DCW}, and \texttt{DCB}, which define words, halfwords, and bytes, respectively.  
These are typically placed within a \texttt{DATA} area to create arrays, lookup tables, buffers, or strings.

\begin{itemize}[nosep]
    \item \texttt{DCD} — Define Constant Word (32 bits per element)
    \item \texttt{DCW} — Define Constant Halfword (16 bits per element)
    \item \texttt{DCB} — Define Constant Byte (8 bits per element)
    \item \texttt{SPACE} — Reserve uninitialized memory (in bytes)
    \item \texttt{FILL} — Fill memory with a specified value for a given length
\end{itemize}

\begin{lstlisting}[caption={Declaring arrays and strings in memory}]
            AREA    MYDATA, DATA, READONLY
NUMBERS     DCD     10, 20, 30, 40        ; array of 32-bit integers
BYTES       DCB     1, 2, 3, 4            ; array of bytes
TEXT        DCB     "HELLO",0             ; null-terminated ASCII string
BUFFER      SPACE   64                    ; reserve 64 bytes (uninitialized)
PATTERN     FILL    0xFF, 64              ; fill 64 bytes with 0xFF
\end{lstlisting}

Each label (e.g., \texttt{NUMBERS}, \texttt{TEXT}) marks the starting address of a data object in memory.  
You can load these addresses into registers using \texttt{LDR R0, =NUMBERS} or \texttt{ADR R0, TEXT}, then access individual elements through the appropriate addressing modes.

\noindent\textit{Note: Strings are stored as consecutive ASCII characters in memory. A terminating zero (\texttt{0x00}) is typically appended to indicate the end of the string, similar to C-style strings.}

\subsection{Addressing Modes}

Addressing modes define how the effective address or operand value is obtained by an instruction. 
The ARM Cortex-M4 supports several common addressing modes, summarized below:

\begin{table}[H]
\centering
\caption{General Addressing Modes in ARM Cortex-M4}
\small
\begin{tabularx}{\linewidth}{@{}l l X@{}}
\toprule
\textbf{Mode} & \textbf{Syntax Example} & \textbf{Description} \\
\midrule
Immediate      & \texttt{MOV R0, \#10}          & Operand is a constant value encoded in the instruction. \\
Register Direct& \texttt{MOV R0, R1}            & Operand is taken directly from a register. \\
Register Indirect & \texttt{LDR R0, [R1]}       & Register holds the address of the operand in memory. \\
Register Offset & \texttt{LDR R0, [R1, R2]}     & Effective address = base register + offset register. \\
Immediate Offset & \texttt{LDR R0, [R1, \#4]}   & Effective address = base register + constant offset. \\
Pre-indexed    & \texttt{LDR R0, [R1, \#4]!}    & Base updated first, then memory access. \\
Post-indexed   & \texttt{LDR R0, [R1], \#4}     & Memory access first, then base register updated. \\
\bottomrule
\end{tabularx}
\vspace{2pt}
\end{table}
\begin{lstlisting}[caption={Examples of Offset, Pre-indexed, and Post-indexed Addressing Modes}]
; Immediate Offset
    LDR     R0, [R1, #4]     ; R0 = word at memory[R1 + 4]
; Register Offset
    LDR     R0, [R1, R2]    ; R0 = word at memory[R1 + R2]
; Pre-indexed
    LDR     R0, [R1, #4]!    ; R1 = R1 + 4, then load R0 = [R1]
; Post-indexed
    LDR     R0, [R1], #4     ; load R0 = [R1], then R1 = R1 + 4
\end{lstlisting}

\newpage
\section{Procedure}

\subsection{Examples}

\subsubsection{Example 1 --- Data Processing Instructions}
This example demonstrates various arithmetic and bitwise operations on registers.
\lstinputlisting[caption={Arithmetic and bitwise operations example}]{snippets/assembly/exp2/example1.asm}
\newpage
\subsubsection{Example 2 --- Load/Store with Different Addressing Modes}
This example demonstrates load and store instructions using various addressing modes.
\lstinputlisting[caption={Load/store with different addressing modes example}]{snippets/assembly/exp2/example3.asm}

\subsection{Tasks}
\subsubsection{Task 1 --- Bitwise Register Manipulation}
Start with \texttt{R0 = 0x12345678}. Perform the following operations and observe the results in the debugger (verify in hex and binary):
\begin{itemize}[nosep]
    \item Clear bits 4--7 (second hex nibble).
    \item Set bits 8--11 (force that nibble to \texttt{F}).
    \item Toggle bits 28--31 (highest nibble).
\end{itemize}
\emph{Hint:} Use \texttt{BIC}, \texttt{ORR}, and \texttt{EOR} with appropriate masks.  

\subsubsection{Task 2 --- Addressing Modes with an Array}
Given:
\begin{lstlisting}
ARRAY   DCD  0x11, 0x22, 0x33, 0x44
OUT     SPACE 16
\end{lstlisting}

Load each element using a different addressing mode, then store to \texttt{OUT}:
\begin{itemize}[nosep]
    \item 0x11 via \emph{immediate offset}
    \item 0x22 via \emph{pre-indexed}       
    \item 0x33 via \emph{post-indexed}       
    \item 0x44 via \emph{register offset}   
\end{itemize}
\emph{Hint:} Put \texttt{ARRAY}'s base in \texttt{R1} (e.g., \texttt{LDR R1, =ARRAY}). Verify \texttt{OUT} in memory after execution.
